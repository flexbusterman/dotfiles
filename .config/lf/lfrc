set ratios 1:2:3
set cleaner ~/.config/lf/cleaner
set previewer ~/.config/lf/preview
# interpreter for shell commands
set shell zsh
# display hidden files
set hidden
# line numbers
set number
set relativenumber true
# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
set shellopts '-eu'
# set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. 'filesep' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"
# leave some space at the top and the bottom of the screen
set scrolloff 10

# Use the `dim` attribute instead of underline for the cursor in the preview pane
set cursorpreviewfmt "\033[7;2m"

# lfrc
cmd fzf-restore ${{
    ids="$(echo -ne '\n'              | \
      trash-restore                   | \
      awk '$1 ~ /^[0-9]+/ {print $0}' | \
      fzf --multi                     | \
      awk '{print $1}'                | \
      sed -z 's/\n/,/g;s/,$/\n/')"
    echo $ids | trash-restore
    clear
}}

# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.
# cmd open &{{
#     case $(file --mime-type -Lb $f) in
#         text/*) lf -remote "send $id \$$EDITOR \$fx";;
#         *) for f in $fx; do $OPENER $f > /dev/null 2> /dev/null & done;;
#     esac
# }}

# cmd open ${{
#     case $f in
#         *.midi) mpv $fx && exit 1;;
#     esac
#     case $(file --mime-type $f -b) in
#         text/*) $EDITOR $fx;;
#         image/*) sxiv $fx;;
#         audio/*) musicadd $fx > /dev/null 2>&1 & done;;
#         video/*) mpv $fx > /dev/null 2>&1 & done;;
#         application/pdf) zathura $fx > /dev/null 2>&1 & done;;
#         *) for f in $fx; do setsid $OPENER $f > /dev/null 2> /dev/null & done;;
#     esac
# }}

# cmds/functions
cmd open ${{
    case $(file --mime-type "$(readlink -f $f)" -b) in
		image/*) setsid -f sxivopen "$f" >/dev/null 2>&1;;
    # application/vnd.openxmlformats-officedocument.spreadsheetml.sheet) localc $fx;;
    # image/vnd.djvu|application/pdf|application/postscript) setsid -f zathura $fx >/dev/null 2>&1;;
    # application/vnd.openxmlformats-officedocument.wordprocessingml.document|application/vnd.oasis.opendocument.text|application/vnd.openxmlformats-officedocument.spreadsheetml.sheet|application/vnd.oasis.opendocument.spreadsheet|application/vnd.oasis.opendocument.spreadsheet-template|application/vnd.openxmlformats-officedocument.presentationml.presentation|application/vnd.oasis.opendocument.presentation-template|application/vnd.oasis.opendocument.presentation|application/vnd.ms-powerpoint|application/vnd.oasis.opendocument.graphics|application/vnd.oasis.opendocument.graphics-template|application/vnd.oasis.opendocument.formula|application/vnd.oasis.opendocument.database) setsid -f libreoffice $fx >/dev/null 2>&1;;
    application/x-sc) setsid -f st -e sc-im $fx >/dev/null 2>&1;;  # Handle .sc files
		audio/*) musicadd $fx >/dev/null 2>&1;;
		video/*) setsid -f mpv $f -quiet >/dev/null 2>&1;;
		application/octet-stream) case ${f##*.} in
            # other applications
            doc|docx|xls|xlsx|odt|ppt|pptx) setsid -f libreoffice $fx >/dev/null 2>&1;;
            ghw) setsid -f gtkwave $f >/dev/null 2>&1;;
            ts) setsid -f mpv $f -quiet >/dev/null 2>&1;;
            smc) setsid -f snes9x-gtk $f -quiet >/dev/null 2>&1;;
            *) setsid -f zathura $fx >/dev/null 2>&1;;
        esac;;
    *) case ${f##*.} in
            rpp|RPP) setsid -f reaper $f >/dev/null 2>&1 &;;  # Handle .rpp and .RPP files
            *) setsid -f $OPENER $f >/dev/null 2>&1;;
        esac;;
    esac
}}

cmd mkdir $mkdir -p "$@"

cmd extract ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	printf "%s\n\t" "$fx"
	printf "extract?[y/N]"
	read ans
	[ $ans = "y" ] && {
		case $fx in
			*.tar.bz2)   tar xjf $fx    ;;
			*.tar.gz)    tar xzf $fx    ;;
			*.bz2)       bunzip2 $fx    ;;
			*.rar)       unrar e $fx    ;;
			*.gz)        gunzip $fx     ;;
			*.tar)       tar xf $fx     ;;
			*.tbz2)      tar xjf $fx    ;;
			*.tgz)       tar xzf $fx    ;;
			*.zip)       unzip $fx      ;;
			*.Z)         uncompress $fx ;;
			*.7z)        7z x $fx       ;;
			*.tar.xz)    tar xf $fx     ;;
		esac
	}
}}

# move current file or selected files to trash folder
# (also see 'man mv' for backup/overwrite options)
cmd trash %set -f; mv $fx ~/.trash

# define a custom 'delete' command
# cmd delete ${{
#     set -f
#     printf "$fx\n"
#     printf "delete?[y/n]"
#     read ans
#     [ "$ans" = "y" ] && rm -rf $fx
# }}

# use '<delete>' key for either 'trash' or 'delete' command
# map <delete> trash
# map <delete> delete

# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $fx;;
        *.tar.gz|*.tgz) tar xzvf $fx;;
        *.tar.xz|*.txz) tar xJvf $fx;;
        *.zip) unzip $fx;;
        *.rar) unrar x $fx;;
        *.7z) 7z x $fx;;
    esac
}}

cmd bulkrename ${{
    tmpfile_old="$(mktemp)"
    tmpfile_new="$(mktemp)"
    [ -n "$fx" ] && fs=$(basename -a $fs) || fs=$(ls)
    echo "$fx" > "$tmpfile_old"
    echo "$fx" > "$tmpfile_new"
    $EDITOR "$tmpfile_new"
    [ "$(wc -l < "$tmpfile_old")" -eq "$(wc -l < "$tmpfile_new")" ] || { rm -f "$tmpfile_old" "$tmpfile_new"; exit 1; }
    paste "$tmpfile_old" "$tmpfile_new" | while IFS="$(printf '\t')" read -r src dst
    do
        [ "$src" = "$dst" ] || [ -e "$dst" ] || mv -- "$src" "$dst"
    done
    rm -f "$tmpfile_old" "$tmpfile_new"
    lf -remote "send $id unselect"
}}

# compress current file or selected files with tar and gunzip
cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd zip ${{
    set -f
    mkdir $1
    cp -r $fx $1
    zip -r $1.zip $1
    rm -rf $1
}}

cmd fzf_jump ${{
    res="$(find . | fzf --reverse --header='Jump to location')"
    if [ -n "$res" ]; then
        if [ -d "$res" ]; then
            cmd="cd"
        else
            cmd="select"
        fi
        res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
        lf -remote "send $id $cmd \"$res\""
    fi
}}
map sf :fzf_jump

cmd fzf_search ${{
    RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
    res="$(
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            fzf --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --layout=reverse --header 'Search in files' \
            | cut -d':' -f1 | sed 's/\\/\\\\/g;s/"/\\"/g'
    )"
    [ -n "$res" ] && lf -remote "send $id select \"$res\""
}}

# https://github.com/gokcehan/lf/wiki/Tips#yank-paths-into-your-clipboard
cmd yank-dirname $dirname -- "$f" | head -c-1 | xclip -i -selection clipboard
cmd yank-path $printf '%s' "$fx" | xclip -i -selection clipboard
cmd yank-basename ${{
    echo "$fx" |
        xargs -r -d '\n' -I {} basename "{}" |
        if [ -n "$fs" ]; then cat; else tr -d '\n'; fi |
        xclip -i -selection clipboard
}}

cmd yank-basename-without-extension ${{
    echo "$fx" |
        xargs -r -d '\n' basename -a |
        awk -e '{
            for (i=length($0); i > 0; i--) {
                if (substr($0, i, 1) == ".") {
                    if (i == 1) print $0
                    else print substr($0, 0, i-1)

                    break
                }
            }
            if (i == 0)
                print $0
        }' |
        if [ -n "$fs" ]; then cat; else tr -d '\n'; fi |
        xclip -i -selection clipboard
}}

map y
map yy :copy
map d
map dd :cut
map dD :delete
map p
map pp :paste
map yn :yank-basename; unselect
map yd :yank-dirname; unselect
map yp :yank-path; unselect
map ye :yank-basename-without-extension; unselect
map yl $dropbox-cli sharelink "$f" | xclip -sel clip &

map sg :fzf_search

# Bindings
map zx :extract
# mkdir command. See wiki if you want it to select created dir
map <c-n> :push %mkdir<space>
# use enter for shell commands
map @ shell
# show the result of execution of previous commands
map ` !true
# execute current file (must be executable)
map x $$f
map X !$f
# dedicated keys for file opener actions
map o &mimeopen $f
map O $mimeopen --ask $f
# trash using gtrash
map D $gtrash put $fx
map U fzf-restore

map a $musicadd $fx

# map a :rename; # after file name
map A :rename; cmd-end # at the very end
map I :rename; cmd-home # at the very beginning
# map i :rename; cmd-home # at the very beginning
map r :bulkrename
map b $setbg $f
